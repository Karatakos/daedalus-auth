import chai from 'chai';
import chaiAsPromised from 'chai-as-promised';

import { Signin, SigninCmd } from '../actions/commands/sign-in.command.js';
import { RefreshTokenQuery } from '../actions/queries/refresh-token.query.js';

import { EventBus } from '../events/event-bus.js';
import { UserSignedInEvent } from '../events/user-signed-in.event.js';
import { UserSignInUnauthorizedEvent, UserSignInUnauthorizedReason } from '../events/user-sign-in-unauthorized.event.js';

import { UserRepo } from '../repository/user.repo.js';
import { UserRepoFactory } from '../repository/user.repo.factory.js';

import { FederatedAccountType } from '../entities/user.js';

chai.use(chaiAsPromised);

const expect = chai.expect;

const userOneValidToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJVUy0xIiwidXNlcm5hbWUiOiJBZHJpYW4iLCJwb2xpY3kiOnsic3R1ZGlvIjoiU1QtMSIsImNhcGFiaWxpdGllcyI6WyJhZG1pbiJdfSwic3RhdHVzIjoiRW5hYmxlZCIsImV4cCI6IjIwMjUtMDgtMDRUMTI6MDc6MzguNzUzWiJ9.-oKioH_5TFPZ7iQblAHj1jk9IPT09-mKJJHaAH02mcc";
const userTwoExpiredToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJVUy0yIiwidXNlcm5hbWUiOiJUaW1teSIsInBvbGljeSI6eyJzdHVkaW8iOiJTVC0xIiwiY2FwYWJpbGl0aWVzIjpbImFkbWluIl19LCJzdGF0dXMiOiJFbmFibGVkIiwiZXhwIjoiMjAyMS0wOC0wNFQxMjowNzozOC43NTNaIn0.VEvFkTw1RDlKEXmtAQFbVX3C2CCjjvnUgy6_qF69YaY";
const userThreeDisabledToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJVUy0yIiwidXNlcm5hbWUiOiJUaW1teSIsInBvbGljeSI6eyJzdHVkaW8iOiJTVC0xIiwiY2FwYWJpbGl0aWVzIjpbImFkbWluIl19LCJzdGF0dXMiOiJEaXNhYmxlZCIsImV4cCI6IjIwMjEtMDgtMDRUMTI6MDc6MzguNzUzWiJ9.B28FS6Jh4rujn68ZTIxTduBz1fzvnOsRNb0jMrjj9QY";

const mockedUsers = [
        {
            PK: "US#1a",
            SK: "US#1a",
            username: "Adrian",             // Username autogenerated
            policy: {studio: 'guid1', capabilities: ['admin']},
            status: "Enabled"
        },
        {
            PK: "US#2a",
            SK: "US#2a",
            username: "Timmy",             // Username autogenerated
            policy: {studio: 'guid1', capabilities: ['admin']},
            status: "Enabled"
        },
        {
            PK: "US#3a",
            SK: "US#3a",
            username: "Sarah",             // Username autogenerated
            policy: {studio: 'guid1', capabilities: ['admin']},
            status: "Disabled"
        },
        {
            PK: "US#3a",
            SK: "RT#" + userThreeDisabledToken      // Refresh token
        },
        {
            PK: "US#2a",
            SK: "RT#" + userTwoExpiredToken         // Refresh token
        },
        {
            PK: "US#1a",
            SK: "RT#" + userOneValidToken           // Refresh token
        },
        {
            PK: "US#1a",
            SK: "FA#ST#KaratakosJP#1983",   // Steam Id
            token: "12345"
        },
        {
            PK: "US#2a",
            SK: "FA#ST#LittleTimmy#1987",   // Steam Id
            token: "12345"
        },
        {
            PK: "US#3a",
            SK: "FA#ST#xDestinyStarzx#1986",   // Steam Id
            token: "12345"
        },
        {
            PK: "ST#1",
            SK: "ST#1",
            name: "Jellyfish Studios"       // Studio name
        },
        {
            PK: "ST#2",
            SK: "ST#2",
            name: "Studio X"                // Studio name
        }
    ];

const userRepo = UserRepoFactory.make(mockedUsers);
const eventBus = new EventBus();

before(() => {
    
});

describe('Given request for a refresh token that doesnt exist', () => {
    it('Should throw error for no refresh token', async () => {
        let refreshTokenQry = new RefreshTokenQuery(userRepo, eventBus);
        await expect(refreshTokenQry.execute("000000")).to.be.rejectedWith("Unauthorized. Refresh token not found, please sign-in again.");
    });
});

describe('Given request for a refresh token that has expired', () => {
    it('Should throw error for expired token', async () => {
        let refreshTokenQry = new RefreshTokenQuery(userRepo, eventBus);
        await expect(refreshTokenQry.execute(userTwoExpiredToken)).to.be.rejectedWith("Unauthorized. Refresh token expired.");
    });
});

describe('Given request for a refresh token where the user was disabled', () => {
    it('Should throw error for the disabled user', async () => {
        let refreshTokenQry = new RefreshTokenQuery(userRepo, eventBus);
        await expect(refreshTokenQry.execute(userThreeDisabledToken)).to.be.rejectedWith("Unauthorized. This account is disabled.");
    });
});

describe('Given request for a valid refresh token', () => {
    it('Should provide an access token', async () => {
        let refreshTokenQry = new RefreshTokenQuery(userRepo, eventBus);
        let token = await refreshTokenQry.execute(userOneValidToken)

        expect(token).to.not.be.empty;
    });
});

describe('Given request to sign-in an existing user', () => {
    it('Should generate a signed-in event with user data and tokens', async () => {
        let signinQuery = new Signin(
            userRepo, 
            eventBus,
            new SigninCmd("KaratakosJP#1983", FederatedAccountType.STEAM, "12345"));
        await signinQuery.execute();

        let event = eventBus.log.find((e) => {
            if (e instanceof UserSignedInEvent) {
                return e;
            }
        });

        expect(event?.userId).to.equal("1a");
        expect(event?.federatedAccountId).to.equal("KaratakosJP#1983");
        expect(event?.accessToken).to.not.be.empty;
        expect(event?.refreshToken).to.not.be.empty;
    });
});

describe('Given request to sign-in a new user', () => {
    it('Should generate a signed-in event with auto generated metadata and tokens', async () => {
        let signinQuery = new Signin(
            userRepo, 
            eventBus,
            new SigninCmd("SomeInvalidUser", FederatedAccountType.STEAM, "12345"));
        await signinQuery.execute();

        let event = eventBus.log.find((e) => {
            if (e instanceof UserSignedInEvent) {
                return e;
            }
        });

        expect(event?.userId).to.not.be.empty;
        expect(event?.federatedAccountId).to.not.be.empty;
        expect(event?.accessToken).to.not.be.empty;
        expect(event?.refreshToken).to.not.be.empty;
    });
});

describe('Given request to sign-in a disabled user', () => {
    it('Should fail with event UserSignInUnauthorizedEvent', async () => {
        let signinQuery = new Signin(
            userRepo, 
            eventBus,
            new SigninCmd("xDestinyStarzx#1986", FederatedAccountType.STEAM, "12345"));
        await signinQuery.execute();

        let event = eventBus.log.find((e) => {
            if (e instanceof UserSignInUnauthorizedEvent) {
                return e;
            }
        });

        expect(event?.federatedAccountId).to.be.equal('xDestinyStarzx#1986');
    });
});




