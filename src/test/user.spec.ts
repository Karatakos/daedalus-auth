import chai from 'chai';
import chaiAsPromised from 'chai-as-promised';

import { SigninHandler, SigninCmd } from '../actions/commands/sign-in.command.js';
import { AccessTokenHandler, AccessTokenQuery } from '../actions/queries/access-token.query.js';

import { EventBus } from '../events/event-bus.js';
import { UserSignedInEvent } from '../events/user-signed-in.event.js';
import { UserSignInUnauthorizedEvent, UserSignInUnauthorizedReason } from '../events/user-sign-in-unauthorized.event.js';

import { User, UserDAO } from '../entities/user.js';
import { UserRepo } from '../repository/user/user.repo.js';
import { UserRepoFactory } from '../repository/user/user.repo.factory.js';

import { FederatedAccountType } from '../entities/user.js';
import { AnyMxRecord } from 'dns';

chai.use(chaiAsPromised);

const expect = chai.expect;

const userOneValidToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJVUy0xIiwidXNlcm5hbWUiOiJBZHJpYW4iLCJwb2xpY3kiOnsic3R1ZGlvIjoiU1QtMSIsImNhcGFiaWxpdGllcyI6WyJhZG1pbiJdfSwic3RhdHVzIjoiRW5hYmxlZCIsImV4cCI6IjIwMjUtMDgtMDRUMTI6MDc6MzguNzUzWiJ9.-oKioH_5TFPZ7iQblAHj1jk9IPT09-mKJJHaAH02mcc";
const userTwoExpiredToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJVUy0yIiwidXNlcm5hbWUiOiJUaW1teSIsInBvbGljeSI6eyJzdHVkaW8iOiJTVC0xIiwiY2FwYWJpbGl0aWVzIjpbImFkbWluIl19LCJzdGF0dXMiOiJFbmFibGVkIiwiZXhwIjoiMjAyMS0wOC0wNFQxMjowNzozOC43NTNaIn0.VEvFkTw1RDlKEXmtAQFbVX3C2CCjjvnUgy6_qF69YaY";
const userThreeDisabledToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJVUy0yIiwidXNlcm5hbWUiOiJUaW1teSIsInBvbGljeSI6eyJzdHVkaW8iOiJTVC0xIiwiY2FwYWJpbGl0aWVzIjpbImFkbWluIl19LCJzdGF0dXMiOiJEaXNhYmxlZCIsImV4cCI6IjIwMjEtMDgtMDRUMTI6MDc6MzguNzUzWiJ9.B28FS6Jh4rujn68ZTIxTduBz1fzvnOsRNb0jMrjj9QY";

const mockedDatastore = [
        {
            PK: "US#1a",
            SK: "US#1a",
            username: "Adrian",             // Username autogenerated
            policy: '{"studio": "guid1", "capabilities": ["admin"]}',
            status: "Enabled"
        },
        {
            PK: "US#2a",
            SK: "US#2a",
            username: "Timmy",             // Username autogenerated
            policy: '{"studio": "guid1", "capabilities": ["admin"]}',
            status: "Enabled"
        },
        {
            PK: "US#3a",
            SK: "US#3a",
            username: "Sarah",             // Username autogenerated
            policy: '{"studio": "guid1", "capabilities": ["admin"]}',
            status: "Disabled"
        },
        {
            PK: "US#3a",
            SK: "RT#" + userThreeDisabledToken      // Refresh token
        },
        {
            PK: "US#2a",
            SK: "RT#" + userTwoExpiredToken         // Refresh token
        },
        {
            PK: "US#1a",
            SK: "RT#" + userOneValidToken           // Refresh token
        },
        {
            PK: "US#1a",
            SK: "FA#ST#KaratakosJP#1983",   // Steam Id
            token: "12345"
        },
        {
            PK: "US#2a",
            SK: "FA#ST#LittleTimmy#1987",   // Steam Id
            token: "12345"
        },
        {
            PK: "US#3a",
            SK: "FA#ST#xDestinyStarzx#1986",   // Steam Id
            token: "12345"
        },
        {
            PK: "ST#1",
            SK: "ST#1",
            name: "Jellyfish Studios"       // Studio name
        },
        {
            PK: "ST#2",
            SK: "ST#2",
            name: "Studio X"                // Studio name
        }
    ];

const userRepo = UserRepoFactory.make(mockedDatastore);
const eventBus = new EventBus();

before(() => {
    // Nothing to setup
});

describe('Refresh token doesnt exist', () => {
    it('Should throw error for no refresh token', async () => {
        const refreshTokenQry = new AccessTokenHandler(userRepo);
        await expect(refreshTokenQry.execute(new AccessTokenQuery("000000")))
            .to.be.rejectedWith("Unauthorized. Refresh token not found, please sign-in again.");
    });
});

describe('Refresh token that has expired', () => {
    it('Should throw error for expired token', async () => {
        const refreshTokenQry = new AccessTokenHandler(userRepo);
        await expect(refreshTokenQry.execute(new AccessTokenQuery(userTwoExpiredToken)))
            .to.be.rejectedWith("Unauthorized. Refresh token expired.");
    });
});

describe('Refresh token for disabled user', () => {
    it('Should throw error for the disabled user', async () => {
        const refreshTokenQry = new AccessTokenHandler(userRepo);
        await expect(refreshTokenQry.execute(new AccessTokenQuery(userThreeDisabledToken)))
            .to.be.rejectedWith("Unauthorized. This account is disabled.");
    });
});

describe('Valid refresh token', () => {
    it('Should provide an access token', async () => {
        const refreshTokenQry = new AccessTokenHandler(userRepo);
        const token = await refreshTokenQry.execute(new AccessTokenQuery(userOneValidToken));

        expect(token).to.not.be.empty;
    });
});

describe('Sign-in an existing user', () => {
    it('Should generate new user account', async () => {
        const signinQuery = new SigninHandler(
            userRepo, 
            eventBus);
        await signinQuery.execute(
            new SigninCmd("KaratakosJP#1983", FederatedAccountType.STEAM, "12345", "0003"));

        const event: UserSignedInEvent = eventBus.log.find((e) => {
            if (e instanceof UserSignedInEvent) {
                return e;
            }
        }) as UserSignedInEvent;

        expect(event?.userId).to.equal("1a");
        expect(event?.federatedAccountId).to.equal("KaratakosJP#1983");
        expect(event?.accessToken).to.not.be.empty;
        expect(event?.refreshToken).to.not.be.empty;
    });
});

describe('Sign-in a new user', () => {
    it('Should generate new token', async () => {
        const signinQuery = new SigninHandler(
            userRepo, 
            eventBus);
        await signinQuery.execute(
            new SigninCmd("SomeInvalidUser", FederatedAccountType.STEAM, "12345", "0001"));

        const event: UserSignedInEvent = eventBus.log.find((e) => {
            if (e instanceof UserSignedInEvent) {
                return e;
            }
        }) as UserSignedInEvent;

        expect(event?.userId).to.not.be.empty;
        expect(event?.federatedAccountId).to.not.be.empty;
        expect(event?.accessToken).to.not.be.empty;
        expect(event?.refreshToken).to.not.be.empty;
    });
});

describe('Sign-in a disabled user', () => {
    it('Should fail with event UserSignInUnauthorizedEvent', async () => {
        const signinQuery = new SigninHandler(
            userRepo, 
            eventBus);
        await signinQuery.execute(
            new SigninCmd("xDestinyStarzx#1986", FederatedAccountType.STEAM, "12345", "0002"));

        const event = eventBus.log.find((e) => {
            if (e instanceof UserSignInUnauthorizedEvent) {
                return e;
            }
        });

        expect(event).to.be.instanceOf(UserSignInUnauthorizedEvent);
    });
});




